# ДЗ 1 - Архитектура системы Маркетплейса: ADR и Техническая спецификация

## Выбор архитектурного стиля

### Контекст и проблематика

Необходимо спроектировать бэкенд для маркетплейса (каталог, заказы, оплата, персонализированные ленты). Основной вызов — обеспечить **масштабируемость** (особенно для "Ленты" и "Каталога") и позволить разным командам работать независимо, не допуская деградации системы в "распределенный монолит".

### Решение: Микросервисная архитектура

Для решения этой задачи мы выбираем микросервисный стиль вместо модульного монолита, опираясь на **Domain-Driven Design (DDD)**.

#### Декомпозиция и границы (Information Hiding)

Система разделена на **Bounded Contexts** для достижения **High Cohesion** (высокой связности внутри сервиса). Каждый сервис инкапсулирует свою бизнес-логику и скрывает детали реализации от других:

- **Auth Service**: Управление сессиями и профилями пользователей.
- **Catalog Service**: Инкапсулирует логику товаров и проверку остатков.
- **Feed Service**: Работает с волатильными данными рекомендаций (Redis).
- **Order Service**: Управление корзиной и жизненным циклом заказов.
- **Payment Service**: Интеграция с платежными шлюзами и история транзакций.

Мы придерживаемся принципа **Information Hiding**: сервис `Order` не знает о структуре таблиц в `Catalog`, взаимодействуя только через стабильные контракты.

#### Управление связанностью (Coupling)

Для минимизации **Coupling** (связанности между сервисами) применены следующие стратегии:

1. **Database per Service**: Исключаем **Common Coupling** (общую БД), что предотвращает разрушение владения данными.
2. **Event-Driven (Асинхронно)**: Для процессов, допускающих **Eventual Consistency** (обновление Ленты через брокер сообщений Kafka/RabbitMQ), что снижает временную связанность.
3. **Синхронный gRPC/REST**: Только для критических операций (например, инициация платежа из заказа), где требуется немедленное подтверждение.

## Анализ компромиссов (Trade-offs)

Любое архитектурное решение --- это выбор между конфликтующими свойствами.

| Критерий                   | Почему это важно для Маркетплейса                                                                               |
| -------------------------- | --------------------------------------------------------------------------------------------------------------- |
| **Масштабируемость**       | В пиковые нагрузки (Черная пятница) мы масштабируем только `Catalog` и `Feed`, не затрагивая всю систему.       |
| **Operational Complexity** | Мы принимаем сложность оркестрации и CI/CD ради возможности **независимого развертывания** команд.              |
| **Data Integrity**         | Жертвуем ACID-транзакциями монолита. Для согласованности между `Order` и `Payment` используем паттерн **Saga**. |
| **Network Latency**        | Межсервисные вызовы добавляют задержки, которые мы минимизируем за счет кэширования в `Feed Service`.           |

#### Альтернатива 1: Модульный Монолит

- Единый развертываемый модуль со строго разделенными модулями (пространствами имен/пакетами) для каждого домена.
- **Плюсы:**
  - Простое развертывание (один бинарник/контейнер).
  - Нулевая сетевая задержка между вызовами.
  - Простой рефакторинг и отладка.
  - Легче управлять согласованностью (возможность единой транзакции БД).
- **Минусы:**
  - Масштабирование по принципу "все или ничего" (нельзя масштабировать только сервис Ленты).
  - Риск увеличения связанности со временем (превращение в спагетти-код).
  - Привязка к технологии (все приложение должно использовать один язык/фреймворк).

#### Альтернатива 2: Сервис-ориентированная архитектура (SOA)

- Более крупные сервисы (например, "Бизнес-сервис" и "Сервис поддержки"), часто использующие Корпоративную Шину Данных (ESB).
- **Плюсы:** Повторное использование корпоративных возможностей.
- **Минусы:** ESB становится узким местом и единой точкой отказа. Часто приводит к "Распределенному монолиту".

## Техническая реализация

Прототип сервиса реализован на **FastAPI**. Использование **Docker** гарантирует идентичность сред и упрощает эксплуатацию.

### Запуск сервиса

1. **Сборка образа:**

```bash
docker build -t marketplace-service ./service
```

2. **Запуск контейнера:**

```bash
docker run -d -p 8000:8000 --name marketplace-app marketplace-service
```

3. **Проверка работоспособности (Health check):**

```bash
curl http://localhost:8000/health
# Возвращает: {"status": "OK"} (или "200 OK")
```

4. **Остановка:**

```bash
docker stop marketplace-app

docker rm marketplace-app
```

## Визуализация архитектуры (C4 Model)

Архитектура зафиксирована на уровне **Container (C4 Level 2)**. Основные компоненты:

- **API Gateway**: Единая точка входа, скрывающая внутреннее устройство системы.
- **Message Broker**: Обеспечивает асинхронную передачу событий между доменами.
- **Isolated DBs**: У каждого сервиса своя БД (PostgreSQL, Redis или MongoDB).

## Итог

**Выбранный вариант:** Микросервисная архитектура с асинхронным взаимодействием через брокер сообщений для обеспечения максимальной гибкости и масштабируемости бизнеса.
